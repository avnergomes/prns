<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>üêï Dog Walking Map v2.4 - Business Codes Support</title>

   

    <!-- Leaflet CSS -->

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <!-- Leaflet Draw CSS -->

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />

   

    <style>

        * {

            margin: 0;

            padding: 0;

            box-sizing: border-box;

        }

        html, body {

            height: 100%;

            width: 100%;

        }

        body {

            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;

            background-color: #f8f9fa;

            display: flex;

            flex-direction: column;

            overflow: hidden;

        }

        .controls {

            background: white;

            padding: 15px 20px;

            box-shadow: 0 2px 5px rgba(0,0,0,0.1);

            display: flex;

            gap: 20px;

            align-items: center;

            flex-wrap: wrap;

            min-height: 60px;

            z-index: 1000;

        }

        .control-group {

            display: flex;

            align-items: center;

            gap: 10px;

        }

        .control-group label {

            font-weight: 600;

            color: #333;

            white-space: nowrap;

        }

        input[type="text"] {

            padding: 6px 10px;

            border: 2px solid #e1e5e9;

            border-radius: 6px;

            font-size: 14px;

            transition: border-color 0.2s;

            background: white;

            width: 200px;

        }

        input[type="text"]:focus {

            outline: none;

            border-color: #667eea;

            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);

        }

        .group-filters {

            display: flex;

            gap: 10px;

            align-items: center;

        }

        .group-filter-btn {

            padding: 6px 12px;

            border: 2px solid #e1e5e9;

            border-radius: 6px;

            background: white;

            cursor: pointer;

            font-weight: 600;

            transition: all 0.2s;

            font-size: 14px;

            user-select: none;

        }

        .group-filter-btn:hover:not(:disabled) {

            border-color: #667eea;

            transform: translateY(-1px);

        }

        .group-filter-btn.active {

            background: #667eea;

            color: white;

            border-color: #667eea;

        }

        .selection-controls {

            display: flex;

            gap: 10px;

            align-items: center;

            border-left: 2px solid #e1e5e9;

            padding-left: 20px;

        }

        .main-content {

            display: flex;

            flex: 1;

            overflow: hidden;

            position: relative;

            height: calc(100vh - 80px);

        }

        .left-panel {

            width: 300px;

            background: white;

            border-right: 2px solid #e1e5e9;

            display: flex;

            flex-direction: column;

            overflow: hidden;

            z-index: 999;

            transition: transform 0.3s ease;

        }

        .panel-toggle {

            display: none;

            position: absolute;

            left: 300px;

            top: 50%;

            transform: translateY(-50%);

            background: white;

            border: 2px solid #e1e5e9;

            border-left: none;

            padding: 10px 5px;

            cursor: pointer;

            z-index: 1000;

            border-radius: 0 5px 5px 0;

        }

        @media (max-width: 768px) {

            .left-panel {

                position: absolute;

                left: 0;

                top: 0;

                bottom: 0;

                transform: translateX(-100%);

                box-shadow: 2px 0 5px rgba(0,0,0,0.1);

            }

           

            .left-panel.open {

                transform: translateX(0);

            }

           

            .panel-toggle {

                display: block;

                left: 0;

            }

           

            .left-panel.open ~ .panel-toggle {

                left: 300px;

            }

        }

        .legend-section {

            border-bottom: 1px solid #e1e5e9;

            padding: 8px;

            overflow-y: auto;

            flex: 1;

            scrollbar-width: thin;

            scrollbar-color: #ccc #f8f9fa;

        }

        .legend-section::-webkit-scrollbar {

            width: 6px;

        }

        .legend-section::-webkit-scrollbar-track {

            background: #f8f9fa;

        }

        .legend-section::-webkit-scrollbar-thumb {

            background: #ccc;

            border-radius: 3px;

        }

        .legend h3 {

            margin-bottom: 8px;

            color: #333;

            font-size: 15px;

        }

        .legend-item {

            display: flex;

            align-items: center;

            margin-bottom: 1px;

            font-size: 12px;

            cursor: pointer;

            padding: 2px 4px;

            border-radius: 3px;

            transition: all 0.2s;

            border: 1px solid transparent;

            user-select: none;

        }

        .legend-item:hover {

            background-color: #f8f9fa;

            border-color: #dee2e6;

            transform: translateX(2px);

        }

        .legend-item.active {

            background-color: #e3f2fd;

            border-color: #2196F3;

            font-weight: bold;

        }

        .legend-color {

            width: 12px;

            height: 12px;

            border-radius: 50%;

            margin-right: 6px;

            border: 2px solid #333;

            flex-shrink: 0;

        }

        .legend-text {

            flex: 1;

            overflow: hidden;

            text-overflow: ellipsis;

            white-space: nowrap;

        }

        .color-picker {

            width: 16px;

            height: 16px;

            border-radius: 50%;

            border: 1px solid #333;

            margin-left: 6px;

            cursor: pointer;

            flex-shrink: 0;

            padding: 0;

            background: none;

            opacity: 0.7;

            transition: opacity 0.2s;

        }

        .color-picker:hover {

            opacity: 1;

        }

        .color-picker::-webkit-color-swatch-wrapper {

            padding: 0;

            border-radius: 50%;

        }

        .color-picker::-webkit-color-swatch {

            border: none;

            border-radius: 50%;

        }

        .edit-section {

            padding: 8px;

            padding-bottom: 20px;

            overflow-y: auto;

            flex-shrink: 0;

            min-height: 180px;

            max-height: 280px;

            border-top: 1px solid #e1e5e9;

        }

        .no-selection {

            text-align: center;

            color: #6c757d;

            font-style: italic;

            margin-top: 5px;

            padding: 0 5px;

            font-size: 11px;

        }

        .btn {

            padding: 8px 12px;

            border: none;

            border-radius: 5px;

            cursor: pointer;

            font-weight: 600;

            transition: all 0.2s;

            font-size: 14px;

            margin: 2px;

            user-select: none;

            display: inline-flex;

            align-items: center;

            gap: 4px;

        }

        .btn:disabled {

            opacity: 0.6;

            cursor: not-allowed;

        }

        .btn:not(:disabled):hover {

            transform: translateY(-1px);

            box-shadow: 0 2px 4px rgba(0,0,0,0.1);

        }

        .btn-primary {

            background: #667eea;

            color: white;

        }

        .btn-secondary {

            background: #6c757d;

            color: white;

        }

        .btn-clear {

            background: #28a745;

            color: white;

        }

        .btn-danger {

            background: #dc3545;

            color: white;

        }

        .btn-warning {

            background: #ffc107;

            color: #212529;

        }

        .btn-info {

            background: #17a2b8;

            color: white;

        }

        .selection-mode-active {

            background: #fff3cd !important;

            border-color: #ffc107 !important;

            color: #856404 !important;

        }

        .map-container {

            flex: 1;

            position: relative;

            background: #f0f0f0;

        }

        #map {

            width: 100%;

            height: 100%;

            background: #f0f0f0;

        }

        .leaflet-tile-pane {

            opacity: 1;

        }

        .leaflet-marker-pane {

            opacity: 1 !important;

            filter: none !important;

        }

        .bulk-edit-panel {

            background: #f8f9fa;

            border: 2px solid #007bff;

            border-radius: 8px;

            padding: 15px;

            margin-bottom: 10px;

            animation: slideIn 0.3s ease;

        }

        @keyframes slideIn {

            from {

                opacity: 0;

                transform: translateY(-10px);

            }

            to {

                opacity: 1;

                transform: translateY(0);

            }

        }

        .bulk-edit-header {

            display: flex;

            justify-content: space-between;

            align-items: center;

            margin-bottom: 15px;

        }

        .bulk-edit-header h4 {

            color: #007bff;

            margin: 0;

        }

        .selected-count {

            background: #007bff;

            color: white;

            padding: 4px 8px;

            border-radius: 4px;

            font-size: 12px;

            font-weight: bold;

        }

        .bulk-edit-controls {

            display: flex;

            gap: 10px;

            align-items: center;

            flex-wrap: wrap;

        }

        .bulk-edit-input {

            flex: 1;

            min-width: 150px;

            padding: 8px;

            border: 2px solid #ddd;

            border-radius: 4px;

            font-size: 14px;

        }

        .bulk-edit-input:focus {

            outline: none;

            border-color: #007bff;

            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);

        }

        .selected-dogs-preview {

            max-height: 120px;

            overflow-y: auto;

            background: white;

            border: 1px solid #ddd;

            border-radius: 4px;

            padding: 8px;

            margin: 10px 0;

            font-size: 12px;

        }

        .selected-dog-item {

            padding: 2px 0;

            border-bottom: 1px solid #eee;

        }

        .selected-dog-item:last-child {

            border-bottom: none;

        }

        .marker-selected {

            filter: drop-shadow(0 0 10px #007bff) brightness(1.2);

            transform: scale(1.2);

        }

        .spinner {

            display: inline-block;

            width: 16px;

            height: 16px;

            border: 2px solid rgba(0,0,0,.1);

            border-radius: 50%;

            border-top-color: #333;

            animation: spin 1s ease-in-out infinite;

        }

        @keyframes spin {

            to { transform: rotate(360deg); }

        }

        @keyframes pulse {

            0% { transform: scale(1); }

            50% { transform: scale(1.1); }

            100% { transform: scale(1); }

        }

        .notification {

            position: fixed;

            top: 20px;

            right: 20px;

            padding: 12px 20px;

            border-radius: 4px;

            box-shadow: 0 2px 5px rgba(0,0,0,0.2);

            z-index: 9999;

            animation: slideInRight 0.3s ease;

            max-width: 350px;

        }

        @keyframes slideInRight {

            from {

                transform: translateX(100%);

                opacity: 0;

            }

            to {

                transform: translateX(0);

                opacity: 1;

            }

        }

        @keyframes fadeOut {

            from { opacity: 1; }

            to { opacity: 0; }

        }

        .notification-error {

            background: #f8d7da;

            color: #721c24;

            border: 1px solid #f5c6cb;

        }

        .notification-success {

            background: #d4edda;

            color: #155724;

            border: 1px solid #c3e6cb;

        }

        .notification-info {

            background: #cfe2ff;

            color: #084298;

            border: 1px solid #b6d4fe;

        }

        .save-indicator {

            position: fixed;

            bottom: 20px;

            right: 20px;

            background: white;

            padding: 10px 15px;

            border-radius: 20px;

            box-shadow: 0 2px 10px rgba(0,0,0,0.2);

            display: none;

            align-items: center;

            gap: 8px;

            z-index: 1000;

            font-size: 14px;

        }

        .save-indicator.saving {

            background: #fff3cd;

            color: #856404;

        }

        .save-indicator.saved {

            background: #d4edda;

            color: #155724;

        }

        .save-indicator.error {

            background: #f8d7da;

            color: #721c24;

        }

        .custom-tooltip {

            background: rgba(0, 0, 0, 0.9) !important;

            border: 1px solid #333 !important;

            color: white !important;

            font-weight: 600 !important;

            font-size: 16px !important;  /* Increased from 12px */

            padding: 8px 12px !important;  /* Increased padding for bigger text */

            border-radius: 4px !important;

            box-shadow: 0 2px 5px rgba(0,0,0,0.4) !important;

            white-space: normal !important;  /* Changed from nowrap to allow wrapping */

            max-width: 250px !important;  /* Set max width for text wrapping */

            text-align: center !important;  /* Center align the text */

            line-height: 1.4 !important;  /* Better line spacing */

        }

       

        .leaflet-tooltip-top:before {

            border-top-color: rgba(0, 0, 0, 0.9) !important;

        }

        .connection-status {

            position: fixed;

            bottom: 20px;

            left: 20px;

            padding: 8px 12px;

            border-radius: 20px;

            font-size: 12px;

            background: white;

            box-shadow: 0 2px 5px rgba(0,0,0,0.1);

            display: none;

            align-items: center;

            gap: 6px;

            z-index: 1000;

        }

        .connection-status.connected {

            background: #d4edda;

            color: #155724;

        }

        .connection-status.disconnected {

            background: #f8d7da;

            color: #721c24;

        }

        .error-message {

            color: #dc3545;

            font-style: italic;

            padding: 10px;

            text-align: center;

        }

        .version-indicator {

            margin-left: auto;

            padding: 0 10px;

            color: #666;

            font-size: 11px;

        }

    </style>

</head>

<body>

    <div class="controls">

        <div class="control-group">

            <label for="searchInput">Search:</label>

            <input type="text" id="searchInput" placeholder="Search dogs, drivers, or addresses..." autocomplete="off" />

        </div>

        <div class="control-group group-filters">

            <button class="group-filter-btn active" data-group="1" id="group1Btn">Group 1 ‚≠ï</button>

            <button class="group-filter-btn active" data-group="2" id="group2Btn">Group 2 ‚ñ≤</button>

            <button class="group-filter-btn active" data-group="3" id="group3Btn">Group 3 ‚ñ†</button>

        </div>

        <div class="selection-controls">

            <button class="btn btn-warning" id="selectionModeBtn">üéØ Select Mode</button>

            <button class="btn btn-danger" id="clearSelectionBtn" style="display: none;">‚úñÔ∏è Clear Selection</button>

        </div>

        <div class="control-group">

            <button class="btn btn-secondary" id="resetColorsBtn">üé® Reset Colors</button>

            <button class="btn btn-info" id="testConnectionBtn">üîå Test Connection</button>

        </div>

       

        <div class="version-indicator">

            v2.4 - Business Codes

        </div>

    </div>

    <div class="main-content">

        <div class="left-panel" id="leftPanel">

            <div class="legend-section">

                <div style="text-align: center; margin-bottom: 6px;">

                    <button class="btn btn-clear" id="showAllBtn" style="width: 100%; padding: 6px 8px; font-size: 12px;">Show All</button>

                </div>

               

                <h3>Drivers</h3>

                <div id="legendContent">Loading...</div>

            </div>

           

            <div class="edit-section">

                <div id="bulkEditPanel" style="display: none;"></div>

                <div id="detailsContent" class="no-selection">

                    Click a marker to edit

                </div>

            </div>

        </div>

       

        <button class="panel-toggle" id="panelToggle">

            <span id="panelToggleIcon">‚óÄ</span>

        </button>

        <div class="map-container">

            <div id="map"></div>

        </div>

    </div>

    <div id="saveIndicator" class="save-indicator" style="display: none;">

        <span class="spinner"></span>

        <span>Saving...</span>

    </div>

    <div id="connectionStatus" class="connection-status" style="display: none;">

        <span>Sheet Connection</span>

    </div>

    <!-- Leaflet JS -->

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <!-- Leaflet Draw JS -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>

   

    <script>

        'use strict';

        // ==================== CONFIGURATION ====================

        const CONFIG = Object.freeze({

            SHEET_ID: '17QMFeALjTRJZdMAn9fJPgeh7meL80scQ1KipKJ4jz2A',

            WORKSHEET_NAME: 'Mymap',

            API_KEY: 'AIzaSyAGLteYp1k98SZo0FMClRgBX0LBsgpMxqI',

            APPS_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbx8j56q2vKpgm2jZu-bL3SxyySZccBK6F8XK-LinPmzHxEJDFh-aY-wIO6gVPfX8NH0dQ/exec',

            DEFAULT_LAT: 42.2968,

            DEFAULT_LNG: -71.2636,

            DEFAULT_ZOOM: 11,

            DEBOUNCE_DELAY: 300,

            MAX_MARKERS: 10000,

            MAX_SELECTION: 500

        });

        // Master color palette

        const ALL_COLORS = Object.freeze([

            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',

            '#bcbd22', '#17becf', '#ff9896', '#98df8a', '#c5b0d5', '#c49c94', '#f7b6d3', '#c7c7c7',

            '#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57', '#FF9FF3', '#54A0FF',

            '#5F27CD', '#00D2D3', '#FF9F43', '#10AC84', '#EE5A24', '#0097E6', '#8C7AE6', '#F79F1F',

            '#A3CB38', '#E74C3C', '#3742FA', '#2F3542', '#FF3838', '#2ECC71', '#9B59B6', '#E67E22',

            '#1ABC9C', '#34495E', '#F39C12', '#E91E63', '#00BCD4', '#607D8B', '#795548', '#009688',

            '#FF5722', '#673AB7', '#3F51B5', '#2196F3', '#03DAC6', '#6200EA', '#FF4081', '#FFAB00',

            '#00E676', '#DD2C00', '#651FFF', '#FF6D00', '#FF1744', '#00E5FF', '#BF360C', '#1B5E20'

        ]);

        // ==================== STATE MANAGEMENT ====================

        const state = {

            map: null,

            markers: [],

            markerLookup: new Map(),

            coordinateLookup: new Map(),

            allData: [],

            filteredData: [],

            colorMap: {},

            selectedMarker: null,

            selectedRow: null,

            currentFilter: null,

            driverColorMap: {},

            customColors: {},

            activeGroups: [1, 2, 3],

            selectionMode: false,

            selectedMarkers: new Set(),

            drawControl: null,

            drawnItems: null,

            isUpdating: false,

            pendingSaves: new Map(),

            saveQueue: [],

            isSaving: false

        };

        // ==================== UTILITY FUNCTIONS ====================

        function showNotification(message, type = 'info', duration = 3000) {

            const existing = document.querySelector('.notification');

            if (existing) {

                existing.remove();

            }

           

            const notification = document.createElement('div');

            notification.className = `notification notification-${type}`;

            notification.textContent = message;

            document.body.appendChild(notification);

           

            if (duration > 0) {

                setTimeout(() => {

                    notification.style.animation = 'fadeOut 0.3s ease';

                    setTimeout(() => {

                        if (notification.parentNode) {

                            notification.remove();

                        }

                    }, 300);

                }, duration);

            }

        }

        function debounce(func, wait) {

            let timeout;

            return function(...args) {

                clearTimeout(timeout);

                timeout = setTimeout(() => func.apply(this, args), wait);

            };

        }

        function escapeHtml(text) {

            if (text == null) return '';

            const div = document.createElement('div');

            div.textContent = String(text);

            return div.innerHTML;

        }

        function validateCoordinates(lat, lng) {

            const latNum = Number(lat);

            const lngNum = Number(lng);

           

            if (!Number.isFinite(latNum) || !Number.isFinite(lngNum)) {

                return false;

            }

           

            if (latNum < -90 || latNum > 90 || lngNum < -180 || lngNum > 180) {

                return false;

            }

           

            if (Math.abs(latNum) < 0.0001 && Math.abs(lngNum) < 0.0001) {

                return false;

            }

           

            return true;

        }

        // Parse group from the Group column - supports multi-groups and business codes (DD, SS, AA, F)

        function parseGroup(groupValue) {

            if (!groupValue) return null;

           

            const originalValue = String(groupValue).trim();

            let strValue = originalValue;

            if (!strValue) return null;

           

            // Remove business codes (DD, SS, AA, F) but keep the group numbers

            // Business code meanings:

            // DD = Discount Day

            // SS = Single Siblings  

            // AA = (business code)

            // F = (business code)

            //

            // Supported patterns:

            // Single groups: 1, 2, 3, 1DD1, 2F2, 3SS3, 1AA1

            // Two groups: 1&2, 2&3 (with codes: 1DD&2, 2SS&3)

            // All three groups: 123, 1DD23, 1SS23, 1AA23, 2DD23, 3DD23

            // Note: Groups 1&3 together always means all three (123)

            //

            // Examples: 3DD3 -> 3, 2F2 -> 2, 1DD&2 -> 12, 1DD23 -> 123

           

            // Handle patterns with & first (like 1DD&2, 2SS&3)

            if (strValue.includes('&')) {

                // Remove business codes from each part

                const parts = strValue.split('&').map(part => {

                    // Remove DD, SS, AA, F from each part

                    return part.replace(/DD|SS|AA|F|XX/g, '').trim();

                });

                strValue = parts.join('&');

            } else {

                // Remove business codes more carefully - only when they appear between numbers

                // This prevents removing F from names like "Fitz"

                strValue = strValue.replace(/(\d)(DD|SS|AA|F|XX)(\d)/g, '$1$3');

                // Also handle cases where business code is at the end like "1DD"

                strValue = strValue.replace(/(\d)(DD|SS|AA|F|XX)$/g, '$1');

            }

           

            // Debug logging for business codes (only log if different from original)

            if (strValue !== originalValue && originalValue.match(/DD|SS|AA|F/)) {

                console.log(`Business code parsed: "${originalValue}" -> "${strValue}"`);

            }

           

            // Now parse the cleaned string

           

            // Handle patterns like "33" -> "3", "22" -> "2", "11" -> "1"

            if (strValue.match(/^([123])\1$/)) {

                return parseInt(strValue[0], 10);

            }

           

            // Handle multi-group combinations with & (only 1&2 or 2&3 are valid)

            if (strValue.includes('&')) {

                const groups = strValue.split('&')

                    .map(g => g.trim())

                    .filter(g => g.match(/^[123]$/))

                    .sort();

                if (groups.length === 2) {

                    // Only valid two-group combinations are 1&2 or 2&3

                    const joined = groups.join('');

                    if (joined === '12' || joined === '23') {

                        return joined;

                    }

                    // If it's 1&3, treat as all three groups

                    if (joined === '13') {

                        return '123';

                    }

                } else if (groups.length === 1) {

                    return parseInt(groups[0], 10);

                }

            }

           

            // Handle combined groups without separators like "12", "23", "123", "13"

            if (strValue.match(/^[123]{2,3}$/)) {

                // Remove duplicates and sort

                const uniqueGroups = [...new Set(strValue.split(''))].sort().join('');

                // If it's "13", treat as all three groups (123)

                if (uniqueGroups === '13') {

                    return '123';

                }

                return uniqueGroups;

            }

           

            // Handle single groups

            if (strValue.match(/^[123]$/)) {

                return parseInt(strValue, 10);

            }

           

            return null;

        }

        // Get unique dog ID

        function getDogId(row) {

            if (!row) return null;

           

            if (row['_uniqueId']) {

                return row['_uniqueId'];

            }

           

            let id = null;

           

            if (row['Dog ID'] && row['Dog ID'].trim()) {

                id = row['Dog ID'].trim();

            } else if (row['Dog Name'] && row['Dog Name'].trim()) {

                id = row['Dog Name'].trim();

                // Use the stored _rowIndex instead of indexOf

                const index = row['_rowIndex'] ?? state.allData.indexOf(row);

                if (index >= 0) {

                    id = `${id}_${index}`;

                }

            } else {

                const index = row['_rowIndex'] ?? state.allData.indexOf(row);

                id = `dog_${index >= 0 ? index : Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            }

           

            row['_uniqueId'] = id;

            return id;

        }

        // Get row's sheet index (accounting for header row)

        function getSheetRowIndex(row) {

            // Use the stored _rowIndex if available, otherwise try to find it

            if (row && typeof row['_rowIndex'] === 'number') {

                // _rowIndex is 0-based from the data rows

                // Add 2: +1 for header row, +1 for 1-based indexing

                return row['_rowIndex'] + 2;

            }

           

            // Fallback: try to find in allData

            const index = state.allData.indexOf(row);

            if (index !== -1) {

                return index + 2;

            }

           

            console.error('Could not determine sheet row index for row:', row);

            return -1;

        }

        // Point in polygon algorithm

        function isPointInPolygon(point, polygon) {

            if (!polygon || polygon.length < 3) return false;

            if (!point || !Number.isFinite(point.lat) || !Number.isFinite(point.lng)) return false;

           

            const x = point.lat, y = point.lng;

            let inside = false;

           

            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {

                const xi = polygon[i].lat, yi = polygon[i].lng;

                const xj = polygon[j].lat, yj = polygon[j].lng;

               

                if (!Number.isFinite(xi) || !Number.isFinite(yi) ||

                    !Number.isFinite(xj) || !Number.isFinite(yj)) {

                    continue;

                }

               

                const intersect = ((yi > y) !== (yj > y)) &&

                    (x < (xj - xi) * (y - yi) / (yj - yi) + xi);

               

                if (intersect) inside = !inside;

            }

           

            return inside;

        }

        // ==================== APPS SCRIPT COMMUNICATION ====================

        async function callAppsScript(payload) {

            try {

                const response = await fetch(CONFIG.APPS_SCRIPT_URL, {

                    method: 'POST',

                    mode: 'no-cors', // Required for Apps Script

                    headers: {

                        'Content-Type': 'text/plain', // Apps Script requires this

                    },

                    body: JSON.stringify(payload)

                });

               

                // Note: With no-cors mode, we can't read the response

                // But the request will still go through

                return { success: true };

               

            } catch (error) {

                console.error('Error calling Apps Script:', error);

                throw error;

            }

        }

        async function testAppsScriptConnection() {

            try {

                console.log('Testing Apps Script connection to:', CONFIG.APPS_SCRIPT_URL);

               

                const statusEl = document.getElementById('connectionStatus');

                if (statusEl) {

                    statusEl.style.display = 'flex';

                    statusEl.className = 'connection-status';

                    statusEl.innerHTML = '<span class="spinner"></span><span>Testing connection...</span>';

                }

               

                // Test with a GET request first

                const response = await fetch(CONFIG.APPS_SCRIPT_URL);

                const text = await response.text();

               

                if (text.includes('Standalone Dog Walking Map Script')) {

                    showNotification('‚úÖ Google Sheets connection verified!', 'success');

                    console.log('Apps Script GET response:', text);

                   

                    if (statusEl) {

                        statusEl.className = 'connection-status connected';

                        statusEl.innerHTML = '‚úÖ Sheet Connected';

                        setTimeout(() => {

                            statusEl.style.display = 'none';

                        }, 3000);

                    }

                   

                    return true;

                } else {

                    showNotification('‚ö†Ô∏è Apps Script found but response unexpected', 'warning');

                    console.log('Unexpected response:', text);

                   

                    if (statusEl) {

                        statusEl.className = 'connection-status disconnected';

                        statusEl.innerHTML = '‚ö†Ô∏è Connection Issue';

                    }

                   

                    return false;

                }

            } catch (error) {

                console.error('Apps Script test failed:', error);

                showNotification('‚ö†Ô∏è Could not connect to Google Sheets', 'error');

               

                const statusEl = document.getElementById('connectionStatus');

                if (statusEl) {

                    statusEl.className = 'connection-status disconnected';

                    statusEl.innerHTML = '‚ùå Not Connected';

                }

               

                return false;

            }

        }

        // ==================== COLOR MANAGEMENT ====================

        function assignDriverColors() {

            if (!state.allData || state.allData.length === 0) {

                state.driverColorMap = {};

                return;

            }

           

            const drivers = new Set();

           

            state.allData.forEach(row => {

                if (row) {

                    // Try Driver first, fall back to Combined if Driver is empty

                    const driverName = (row['Driver'] && row['Driver'].trim()) ?

                                     row['Driver'].trim() :

                                     (row['Combined'] ? row['Combined'].trim() : '');

                    if (driverName) {

                        drivers.add(driverName);

                    }

                }

            });

           

            const sortedDrivers = Array.from(drivers).sort();

            const newColorMap = {};

           

            sortedDrivers.forEach((driver, index) => {

                // Keep existing custom colors

                if (state.customColors[driver]) {

                    newColorMap[driver] = state.customColors[driver];

                } else if (state.driverColorMap[driver]) {

                    newColorMap[driver] = state.driverColorMap[driver];

                } else if (index < ALL_COLORS.length) {

                    newColorMap[driver] = ALL_COLORS[index];

                } else {

                    // Generate a color for drivers beyond the palette

                    let hash = 0;

                    for (let i = 0; i < driver.length; i++) {

                        hash = ((hash << 5) - hash) + driver.charCodeAt(i);

                        hash = hash & hash;

                    }

                    const hue = Math.abs(hash) % 360;

                    newColorMap[driver] = `hsl(${hue}, 70%, 50%)`;

                }

            });

           

            state.driverColorMap = newColorMap;

            console.log('Assigned colors to', sortedDrivers.length, 'drivers');

        }

        function getDriverColor(name) {

            if (!name || name.trim() === '') return '#999999';

            const trimmedName = name.trim();

           

            // Special case: Black for unassigned drivers

            if (trimmedName.toLowerCase().includes('unassigned')) {

                return '#000000';

            }

           

            if (state.customColors[trimmedName]) return state.customColors[trimmedName];

            return state.driverColorMap[trimmedName] || '#999999';

        }

        function changeCustomColor(categoryName, newColor) {

            console.log('Changing color for:', categoryName, 'to:', newColor);

            state.customColors[categoryName] = newColor;

            assignDriverColors();

            updateMap();

            showNotification(`Color updated for ${categoryName}`, 'success', 2000);

        }

        // ==================== MARKER CREATION WITH PROPER SHAPES ====================

        function createMarkerIcon(color, isSelected = false, markerType = 'circle', group = null, isInSelection = false, dogName = null, hasCallout = false) {

            // Special handling for Park and Field - DIAMONDS

            if (dogName) {

                const dogNameLower = dogName.toLowerCase();

                if (dogNameLower === 'park' || dogNameLower === 'field') {

                    const isPark = dogNameLower === 'park';

                    const strokeColor = isInSelection ? '#007bff' : (isSelected ? '#007bff' : '#666666');

                    const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);

                    const size = isInSelection ? 28 : 24;

                    const fillColor = isPark ? '#FFFFFF' : '#000000';  // Park = white, Field = black

                   

                    return L.divIcon({

                        html: `<svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">

                            <path d="M${size/2} 2 L${size-2} ${size/2} L${size/2} ${size-2} L2 ${size/2} Z"

                                  fill="${fillColor}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>

                        </svg>`,

                        className: `custom-diamond-marker ${isInSelection ? 'marker-selected' : ''}`,

                        iconSize: [size, size],

                        iconAnchor: [size/2, size/2]

                    });

                }

            }

           

            color = color || '#999999';

            const strokeColor = hasCallout ? '#ff0000' : (isInSelection ? '#007bff' : (isSelected ? '#007bff' : '#000000'));

            const strokeWidth = isSelected ? 3 : (isInSelection ? 3 : 2);

            const size = isInSelection ? 16 : 13;

           

            let icon;

           

            try {

                if (group === 2) {

                    // Triangle for Group 2

                    const svgSize = size + 3;

                    icon = L.divIcon({

                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">

                            <path d="M${svgSize/2} 2 L${svgSize-2} ${svgSize-2} L2 ${svgSize-2} Z"

                                  fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>

                        </svg>`,

                        className: `custom-triangle-marker ${isInSelection ? 'marker-selected' : ''}`,

                        iconSize: [svgSize, svgSize],

                        iconAnchor: [svgSize/2, svgSize/2]

                    });

                } else if (group === 3) {

                    // Square for Group 3

                    icon = L.divIcon({

                        html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,

                        className: `custom-square-marker ${isInSelection ? 'marker-selected' : ''}`,

                        iconSize: [size, size],

                        iconAnchor: [size/2, size/2]

                    });

                } else if (group === '12') {

                    // Star for Group 1&2

                    const svgSize = size + 4;

                    icon = L.divIcon({

                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">

                            <polygon points="${svgSize/2},2 ${svgSize*0.6},${svgSize*0.4} ${svgSize-2},${svgSize*0.4} ${svgSize*0.7},${svgSize*0.6} ${svgSize*0.8},${svgSize-2} ${svgSize/2},${svgSize*0.75} ${svgSize*0.2},${svgSize-2} ${svgSize*0.3},${svgSize*0.6} 2,${svgSize*0.4} ${svgSize*0.4},${svgSize*0.4}"

                                     fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>

                        </svg>`,

                        className: `custom-star-marker ${isInSelection ? 'marker-selected' : ''}`,

                        iconSize: [svgSize, svgSize],

                        iconAnchor: [svgSize/2, svgSize/2]

                    });

                } else if (group === '23') {

                    // Trapezoid for Group 2&3

                    const svgSize = size + 4;

                    icon = L.divIcon({

                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">

                            <path d="M3 2 L${svgSize-3} 2 L${svgSize-5} ${svgSize-2} L5 ${svgSize-2} Z"

                                  fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>

                        </svg>`,

                        className: `custom-trapezoid-marker ${isInSelection ? 'marker-selected' : ''}`,

                        iconSize: [svgSize, svgSize],

                        iconAnchor: [svgSize/2, svgSize/2]

                    });

                } else if (group === '123') {

                    // Hexagon for Group 1&2&3

                    const svgSize = size + 4;

                    const cx = svgSize/2;

                    const cy = svgSize/2;

                    const r = (svgSize-4)/2;

                    icon = L.divIcon({

                        html: `<svg width="${svgSize}" height="${svgSize}" viewBox="0 0 ${svgSize} ${svgSize}" style="filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.3)); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}">

                            <polygon points="${cx+r},${cy} ${cx+r/2},${cy-r*0.866} ${cx-r/2},${cy-r*0.866} ${cx-r},${cy} ${cx-r/2},${cy+r*0.866} ${cx+r/2},${cy+r*0.866}"

                                     fill="${color}" stroke="${strokeColor}" stroke-width="${strokeWidth}"/>

                        </svg>`,

                        className: `custom-hexagon-marker ${isInSelection ? 'marker-selected' : ''}`,

                        iconSize: [svgSize, svgSize],

                        iconAnchor: [svgSize/2, svgSize/2]

                    });

                } else {

                    // Circle for Group 1 (default)

                    icon = L.divIcon({

                        html: `<div style="width: ${size}px; height: ${size}px; background-color: ${color}; border: ${strokeWidth}px solid ${strokeColor}; border-radius: 50%; box-shadow: 0 2px 4px rgba(0,0,0,0.3); ${isInSelection ? 'animation: pulse 2s infinite;' : ''}"></div>`,

                        className: `custom-marker ${isInSelection ? 'marker-selected' : ''}`,

                        iconSize: [size, size],

                        iconAnchor: [size/2, size/2]

                    });

                }

               

                return icon;

               

            } catch (error) {

                console.error('Error creating marker icon:', error);

                // Fallback to simple circle

                return L.divIcon({

                    html: `<div style="width: 13px; height: 13px; background-color: #999999; border: 2px solid #000000; border-radius: 50%;"></div>`,

                    className: 'custom-marker-fallback',

                    iconSize: [16, 16],

                    iconAnchor: [8, 8]

                });

            }

        }

        // ==================== MAP INITIALIZATION ====================

        function initMap() {

            try {

                console.log('Initializing map...');

               

                if (typeof L === 'undefined') {

                    throw new Error('Leaflet library not loaded');

                }

               

                state.map = L.map('map', {

                    center: [CONFIG.DEFAULT_LAT, CONFIG.DEFAULT_LNG],

                    zoom: CONFIG.DEFAULT_ZOOM,

                    preferCanvas: true,

                    zoomControl: true,

                    attributionControl: true

                });

               

                // Using Stamen Toner for high contrast streets

                const tileUrl = 'https://stamen-tiles.a.ssl.fastly.net/toner/{z}/{x}/{y}.png';

               

                console.log('Loading map tiles: Stamen Toner (High contrast for clear streets)');

               

                const tileLayer = L.tileLayer(tileUrl, {

                    attribution: 'Map tiles by Stamen Design, under CC BY 3.0. Data by OpenStreetMap, under ODbL.',

                    maxZoom: 19,

                    minZoom: 2,

                    errorTileUrl: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='

                });

               

                let fallbackLayer = null;
                /* =======================================================================
                 * FREE SATELLITE LAYERS (Esri World Imagery + Sentinel‚Äë2 Cloudless)
                 * -----------------------------------------------------------------------
                 * What this adds:
                 *  - Two new base layers with global satellite imagery:
                 *      ‚Ä¢ Esri World Imagery (high-res, near-worldwide)
                 *      ‚Ä¢ Sentinel‚Äë2 Cloudless (EOX global cloud-free mosaic)
                 *  - One optional labels-only overlay to place street/city labels
                 *  - A Leaflet layers control to toggle between Streets and Satellite
                 *
                 * Notes on usage:
                 *  - These are free to use with attribution, adequate for most apps.
                 *  - DO NOT use unofficial Google tiles (license restricted).
                 *  - You can switch the default base by changing which layer is added via .addTo(state.map).
                 * ======================================================================= */
                
                // --- Satellite base layers (free) ---
                const esriWorldImagery = L.tileLayer(
                    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', 
                    {
                        attribution: 'Tiles ¬© Esri ‚Äî Sources: Esri, Maxar, Earthstar Geographics, USDA, USGS, AeroGRID, IGN, GIS User Community',
                        maxZoom: 19
                    }
                );
                
                const sentinel2Cloudless = L.tileLayer(
                    'https://tiles.maps.eox.at/wmts/1.0.0/s2cloudless_3857/default/2021-06-01/GoogleMapsCompatible/{z}/{x}/{y}.jpg',
                    {
                        attribution: 'Sentinel-2 cloudless ‚Äî ¬© ESA, rendered by EOX',
                        maxZoom: 18
                    }
                );
                
                // Optional: labels-only overlay (place over satellite if you want place names/roads)
                const labelsOverlay = L.tileLayer(
                    'https://{s}.basemaps.cartocdn.com/labels_only/{z}/{x}/{y}.png',
                    {
                        attribution: '¬© OpenStreetMap contributors ¬© CARTO',
                    }
                );


                let tileLoadTimeout = null;

               

                // Check if tiles are loading after 5 seconds

                tileLoadTimeout = setTimeout(() => {

                    const tiles = document.querySelectorAll('.leaflet-tile');

                    if (tiles.length === 0 && !fallbackLayer) {

                        console.warn('No tiles loaded - switching to fallback');

                        showNotification('Stamen server not responding, trying fallback...', 'info');

                       

                        // Try CartoDB Positron as fallback

                        fallbackLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {

                            attribution: '¬© OpenStreetMap contributors ¬© CARTO',

                            maxZoom: 19

                        });

                        state.map.removeLayer(tileLayer);

                        fallbackLayer.addTo(state.map);

                    }

                }, 5000);

               

                tileLayer.on('tileerror', function(error) {

                    console.error('Tile load error:', error);

                    // Clear the timeout if we're switching to fallback

                    if (tileLoadTimeout) {

                        clearTimeout(tileLoadTimeout);

                        tileLoadTimeout = null;

                    }

                   

                    // Fallback to CartoDB if Stamen fails

                    if (!fallbackLayer) {

                        console.log('Switching to fallback map provider (CartoDB Positron)...');

                        fallbackLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {

                            attribution: '¬© OpenStreetMap contributors ¬© CARTO',

                            maxZoom: 19

                        });

                        state.map.removeLayer(tileLayer);

                        fallbackLayer.addTo(state.map);

                        showNotification('Using fallback map tiles', 'info');

                    }

                });

               

                tileLayer.on('tileload', function() {

                    // Clear timeout on successful load

                    if (tileLoadTimeout) {

                        clearTimeout(tileLoadTimeout);

                        tileLoadTimeout = null;

                    }

                });

               

                tileLayer.addTo(state.map);

               

                
                // --- Layers control: switch between Streets and Satellite ---
                const baseLayers = {
                    'Streets (Stamen Toner)': tileLayer,
                    'Streets (Carto Light)': fallbackLayer,
                    'Satellite (Esri)': esriWorldImagery,
                    'Satellite (Sentinel‚Äë2 Cloudless)': sentinel2Cloudless
                };
                const overlays = {
                    'Labels (overlay)': labelsOverlay
                };
                L.control.layers(baseLayers, overlays, { position: 'topleft', collapsed: true }).addTo(state.map);
// Check if tiles are loading after a short delay

                setTimeout(() => {

                    const tiles = document.querySelectorAll('.leaflet-tile');

                    const loadedTiles = document.querySelectorAll('.leaflet-tile-loaded');

                    if (tiles.length === 0) {

                        console.warn('No tiles found - map provider may be down');

                        console.warn('Current tile URL pattern:', tileUrl);

                        showNotification('Map tiles not loading - check console for details', 'error');

                    } else {

                        console.log(`Map tiles status: ${tiles.length} total, ${loadedTiles.length} loaded`);

                        if (loadedTiles.length === 0) {

                            console.warn('Tiles found but none loaded - possible network issue');

                        }

                    }

                }, 3000);

               

                state.map.on('error', function(e) {

                    console.error('Map error:', e);

                });

                console.log('Map initialized successfully');

               

            } catch (error) {

                console.error('Error initializing map:', error);

                showNotification('Failed to initialize map. Please refresh the page.', 'error', 0);

            }

        }

        // ==================== DATA LOADING ====================

        async function loadData() {

            showNotification('Loading data from Google Sheets...', 'info');

           

            try {

                if (!CONFIG.SHEET_ID || !CONFIG.API_KEY) {

                    throw new Error('Sheet ID or API key not configured');

                }

               

                const url = `https://sheets.googleapis.com/v4/spreadsheets/${CONFIG.SHEET_ID}/values/${CONFIG.WORKSHEET_NAME}?key=${CONFIG.API_KEY}`;

               

                console.log(`Loading data from sheet: "${CONFIG.WORKSHEET_NAME}"`);

               

                const response = await fetch(url);

               

                if (!response.ok) {

                    if (response.status === 403) {

                        throw new Error('Access denied - check API key permissions');

                    } else if (response.status === 404) {

                        throw new Error(`Sheet not found - verify worksheet name "${CONFIG.WORKSHEET_NAME}"`);

                    } else {

                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);

                    }

                }

               

                const data = await response.json();

               

                if (!data || !data.values || data.values.length < 2) {

                    throw new Error('No data found in sheet');

                }

               

                const headers = data.values[0];

                const rows = data.values.slice(1);

               

                console.log('Headers from Google Sheet:', headers);

               

                // Validate required columns

                const requiredColumns = ['Dog Name', 'Latitude', 'Longitude', 'Group'];

                const missingColumns = requiredColumns.filter(col => !headers.includes(col));

               

                if (missingColumns.length > 0) {

                    console.warn(`Missing columns: ${missingColumns.join(', ')}`);

                }

               

                // Process data

                const processedData = [];

                let validRows = 0;

                const invalidRows = [];

               

                rows.forEach((row, index) => {

                    try {

                        const obj = {};

                        headers.forEach((header, headerIndex) => {

                            obj[header] = row[headerIndex] || '';

                        });

                       

                        if (!obj['Dog Name'] || obj['Dog Name'].trim() === '') {

                            invalidRows.push(index + 2);

                            return;

                        }

                       

                        const lat = parseFloat(obj['Latitude']);

                        const lng = parseFloat(obj['Longitude']);

                       

                        if (!validateCoordinates(lat, lng)) {

                            invalidRows.push(index + 2);

                            return;

                        }

                       

                        obj['_lat'] = lat;

                        obj['_lng'] = lng;

                        obj['_rowIndex'] = index;  // Store the original row index (0-based, excluding header)

                       

                        processedData.push(obj);

                        validRows++;

                       

                    } catch (rowError) {

                        console.warn(`Error processing row ${index + 2}:`, rowError);

                        invalidRows.push(index + 2);

                    }

                });

               

                if (validRows === 0) {

                    throw new Error('No valid data rows found');

                }

               

                state.allData = processedData;

                state.markerLookup.clear();

                state.coordinateLookup.clear();

               

                let message = `Loaded ${validRows} locations`;

                if (invalidRows.length > 0) {

                    const showRows = invalidRows.slice(0, 5);

                    const moreText = invalidRows.length > 5 ? ` and ${invalidRows.length - 5} more` : '';

                    message += ` (Invalid rows: ${showRows.join(', ')}${moreText})`;

                }

                showNotification(message, 'success');

               

                assignDriverColors();

                updateMap();

               

            } catch (error) {

                console.error('Data loading error:', error);

                showNotification('Error loading data: ' + error.message, 'error');

               

                state.allData = [];

                state.markers = [];

                state.filteredData = [];

                state.markerLookup.clear();

                state.coordinateLookup.clear();

            }

        }

        // ==================== MAP UPDATE ====================

        function updateMap() {

            try {

                // Clear existing markers

                state.markers.forEach(m => {

                    if (m && m.marker) {

                        try {

                            m.marker.off();

                            if (state.map.hasLayer(m.marker)) {

                                state.map.removeLayer(m.marker);

                            }

                        } catch (e) {

                            console.warn('Error removing marker:', e);

                        }

                    }

                });

                state.markers = [];

                state.coordinateLookup.clear();

                const searchInput = document.getElementById('searchInput');

                const searchTerm = searchInput ? searchInput.value.toLowerCase().trim() : '';

                if (!state.allData || state.allData.length === 0) {

                    updateLegend();

                    return;

                }

                // Filter data

                state.filteredData = state.allData.filter(row => {

                    if (!row) return false;

                   

                    // Search filter

                    if (searchTerm) {

                        const searchFields = [

                            row['Dog Name'],

                            row['Address'],

                            row['Driver'],

                            row['Combined'],

                            row['Callout'],

                            row['Dog ID']

                        ].filter(Boolean).join(' ').toLowerCase();

                       

                        if (!searchFields.includes(searchTerm)) {

                            return false;

                        }

                    }

                   

                    // Group filter (using parseGroup to handle business codes)

                    const group = parseGroup(row['Group']);

                    if (group !== null) {

                        if (typeof group === 'string' && group.length > 1) {

                            // Multi-group: check if any active group is in the combination

                            const hasActiveGroup = group.split('').some(g => state.activeGroups.includes(parseInt(g)));

                            if (!hasActiveGroup) {

                                return false;

                            }

                        } else if (typeof group === 'number') {

                            // Single group

                            if (!state.activeGroups.includes(group)) {

                                return false;

                            }

                        }

                    } else {

                        // If no valid group, filter out when group filters are active

                        if (state.activeGroups.length < 3) {

                            return false;

                        }

                    }

                   

                    // Driver filter

                    if (state.currentFilter !== null) {

                        const rowDriver = row['Driver'] || row['Combined'] || '';

                        if (rowDriver !== state.currentFilter) {

                            return false;

                        }

                    }

                   

                    return true;

                });

                // Build color map for drivers

                state.colorMap = {};

                state.allData.forEach(row => {

                    if (row && (row['Driver'] || row['Combined'])) {

                        const driver = row['Driver'] || row['Combined'] || '';

                        if (driver) {

                            state.colorMap[driver] = getDriverColor(driver);

                        }

                    }

                });

                // Create markers

                state.filteredData.forEach(row => {

                    if (!row) return;

                   

                    try {

                        const lat = row['_lat'] ?? parseFloat(row['Latitude']);

                        const lng = row['_lng'] ?? parseFloat(row['Longitude']);

                       

                        if (!validateCoordinates(lat, lng)) return;

                       

                        // Handle overlapping coordinates

                        const coordKey = `${lat.toFixed(6)},${lng.toFixed(6)}`;

                        const existingCount = state.coordinateLookup.get(coordKey) || 0;

                        state.coordinateLookup.set(coordKey, existingCount + 1);

                       

                        const offsetLat = existingCount > 0 ? lat + (existingCount * 0.00001) : lat;

                        const offsetLng = existingCount > 0 ? lng + (existingCount * 0.00001) : lng;

                        const driver = row['Driver'] || row['Combined'] || '';

                        let color = state.colorMap[driver] || '#999999';

                       

                        // Special case: Black for unassigned drivers

                        if (driver.toLowerCase().includes('unassigned')) {

                            color = '#000000';

                        }

                       

                        const group = parseGroup(row['Group']);

                        const dogId = getDogId(row);

                        const isInSelection = dogId && state.selectedMarkers.has(dogId);

                        const hasCallout = row['Callout'] && row['Callout'].trim();

                       

                        // Format tooltip as "Driver:Group" then dog name on new line, with count if available, and notes if present

                        const driverDisplay = driver || 'No Driver';

                        const groupDisplay = row['Group'] || '?';  // Use original Group value with business codes intact

                        const dogNameDisplay = row['Dog Name'] || 'Unknown';

                        const countValue = row['Count'] || '';

                        const notesValue = row['Notes'] || '';

                       

                        // Build tooltip with count included if present

                        let tooltipHtml = `<div style="text-align: center;"><strong>${escapeHtml(driverDisplay)}:${escapeHtml(groupDisplay)}</strong>`;

                        if (countValue && countValue.toString().trim() !== '') {

                            tooltipHtml += `  <span style="color: #ff6b6b; font-weight: bold;">(${escapeHtml(countValue)})</span>`;

                        }

                        tooltipHtml += `<br/>${escapeHtml(dogNameDisplay)}`;

                       

                        // Add notes if present

                        if (notesValue && notesValue.toString().trim() !== '') {

                            tooltipHtml += `<br/><span style="font-style: italic; color: white;">${escapeHtml(notesValue)}</span>`;

                        }

                       

                        tooltipHtml += `</div>`;

                       

                        const marker = L.marker([offsetLat, offsetLng], {

                            icon: createMarkerIcon(color, false, 'group', group, isInSelection, row['Dog Name'], hasCallout),

                            riseOnHover: true

                        });

                        // Add marker to map first

                        marker.addTo(state.map);

                       

                        // Create and bind tooltip

                        marker.bindTooltip(tooltipHtml, {

                            permanent: false,

                            direction: 'top',

                            offset: [0, -15],  // Adjusted offset for bigger tooltip

                            className: 'custom-tooltip',

                            opacity: 0.95

                        });

                        // Store additional data for the marker

                        marker._rowData = row;

                       

                        const markerData = {marker, row, index: row['_rowIndex'] ?? state.allData.indexOf(row), group};

                       

                        if (dogId) {

                            state.markerLookup.set(dogId, markerData);

                        }

                       

                        marker.on('click', function(e) {

                            try {

                                if (state.selectionMode) {

                                    e.originalEvent.stopPropagation();

                                    const dogId = getDogId(row);

                                    if (!dogId) return;

                                   

                                    if (state.selectedMarkers.has(dogId)) {

                                        state.selectedMarkers.delete(dogId);

                                    } else if (state.selectedMarkers.size < CONFIG.MAX_SELECTION) {

                                        state.selectedMarkers.add(dogId);

                                    } else {

                                        showNotification(`Maximum ${CONFIG.MAX_SELECTION} markers can be selected`, 'error');

                                        return;

                                    }

                                   

                                    updateSelectedMarkersDisplay();

                                    updateBulkEditPanel();

                                } else {

                                    const validIndex = row['_rowIndex'] ?? state.allData.indexOf(row);

                                    selectMarker(marker, row, validIndex, group);

                                }

                            } catch (clickError) {

                                console.error('Error handling marker click:', clickError);

                                showNotification('Error handling marker click', 'error');

                            }

                        });

                        state.markers.push(markerData);

                       

                    } catch (markerError) {

                        console.warn('Error creating marker:', markerError);

                    }

                });

                updateLegend();

               

                // Fit bounds if we have markers

                if (state.markers.length > 0 && state.markers.length < 100) {

                    const group = L.featureGroup(state.markers.map(m => m.marker));

                    state.map.fitBounds(group.getBounds().pad(0.1));

                }

               

            } catch (error) {

                console.error('Error in updateMap:', error);

                showNotification('Error updating map display', 'error');

            }

        }

        // ==================== SELECTION MODE ====================

        function toggleSelectionMode() {

            state.selectionMode = !state.selectionMode;

           

            const btn = document.getElementById('selectionModeBtn');

            const clearBtn = document.getElementById('clearSelectionBtn');

           

            if (!btn || !clearBtn) return;

           

            if (state.selectionMode) {

                btn.textContent = 'üéØ Exit Select Mode';

                btn.classList.add('selection-mode-active');

                clearBtn.style.display = 'inline-block';

               

                enableDrawingTools();

                showNotification('Draw a polygon around markers to select them', 'info');

            } else {

                btn.textContent = 'üéØ Select Mode';

                btn.classList.remove('selection-mode-active');

                clearBtn.style.display = 'none';

               

                disableDrawingTools();

                clearSelection();

            }

        }

        function enableDrawingTools() {

            if (!state.map || !L.Control.Draw) {

                console.error('Leaflet.draw library not loaded');

                return;

            }

           

            try {

                if (!state.drawnItems) {

                    state.drawnItems = new L.FeatureGroup();

                    state.map.addLayer(state.drawnItems);

                }

                if (!state.drawControl) {

                    state.drawControl = new L.Control.Draw({

                        position: 'topleft',

                        edit: {

                            featureGroup: state.drawnItems,

                            remove: true,

                            edit: true

                        },

                        draw: {

                            polygon: {

                                allowIntersection: false,

                                drawError: {

                                    color: '#e1e100',

                                    message: '<strong>Error!</strong> Shape intersects itself!'

                                },

                                shapeOptions: {

                                    color: '#007bff',

                                    fillColor: '#007bff',

                                    fillOpacity: 0.2,

                                    weight: 3

                                },

                                showArea: true

                            },

                            rectangle: {

                                shapeOptions: {

                                    color: '#007bff',

                                    fillColor: '#007bff',

                                    fillOpacity: 0.2,

                                    weight: 3

                                }

                            },

                            circle: false,

                            marker: false,

                            circlemarker: false,

                            polyline: false

                        }

                    });

                   

                    state.map.addControl(state.drawControl);

                }

                state.map.off('draw:created').on('draw:created', onDrawCreated);

                state.map.off('draw:deleted').on('draw:deleted', onDrawDeleted);

                state.map.off('draw:edited').on('draw:edited', onDrawEdited);

               

            } catch (error) {

                console.error('Error enabling drawing tools:', error);

            }

        }

        function disableDrawingTools() {

            try {

                if (state.map) {

                    state.map.off('draw:created');

                    state.map.off('draw:deleted');

                    state.map.off('draw:edited');

                }

                if (state.drawControl && state.map && state.map.hasLayer(state.drawControl)) {

                    state.map.removeControl(state.drawControl);

                }

                state.drawControl = null;

                if (state.drawnItems) {

                    state.drawnItems.clearLayers();

                    if (state.map && state.map.hasLayer(state.drawnItems)) {

                        state.map.removeLayer(state.drawnItems);

                    }

                }

                state.drawnItems = null;

            } catch (error) {

                console.error('Error disabling drawing tools:', error);

            }

        }

        function onDrawCreated(e) {

            if (!state.selectionMode || !state.drawnItems) return;

           

            const layer = e.layer;

            if (!layer) return;

           

            try {

                state.drawnItems.addLayer(layer);

               

                selectMarkersInPolygonAdditive(layer);

                updateSelectedMarkersDisplay();

                updateBulkEditPanel();

               

                const shapeCount = state.drawnItems.getLayers().length;

                if (shapeCount > 10) {

                    showNotification('Maximum 10 selection areas allowed', 'error');

                    const layers = state.drawnItems.getLayers();

                    if (layers.length > 0) {

                        state.drawnItems.removeLayer(layers[0]);

                    }

                }

               

            } catch (error) {

                console.error('Error in onDrawCreated:', error);

            }

        }

        function onDrawDeleted(e) {

            if (!state.selectionMode || !state.drawnItems) return;

           

            try {

                state.selectedMarkers.clear();

               

                state.drawnItems.eachLayer(function(layer) {

                    if (layer) {

                        selectMarkersInPolygonAdditive(layer);

                    }

                });

               

                updateSelectedMarkersDisplay();

                updateBulkEditPanel();

            } catch (error) {

                console.error('Error in onDrawDeleted:', error);

            }

        }

        function onDrawEdited(e) {

            if (!state.selectionMode || !state.drawnItems) return;

           

            try {

                state.selectedMarkers.clear();

               

                state.drawnItems.eachLayer(function(layer) {

                    if (layer) {

                        selectMarkersInPolygonAdditive(layer);

                    }

                });

               

                updateSelectedMarkersDisplay();

                updateBulkEditPanel();

            } catch (error) {

                console.error('Error in onDrawEdited:', error);

            }

        }

        function selectMarkersInPolygonAdditive(polygon) {

            if (!state.selectionMode || !state.markers || state.markers.length === 0) return;

           

            const bounds = polygon.getBounds();

           

            state.markers.forEach(markerData => {

                if (!markerData || !markerData.marker || !markerData.row) return;

               

                const latLng = markerData.marker.getLatLng();

                if (!latLng) return;

               

                if (!bounds.contains(latLng)) return;

               

                let isInside = false;

                try {

                    if (polygon instanceof L.Polygon || polygon instanceof L.Rectangle) {

                        const latlngs = polygon.getLatLngs();

                        if (latlngs && latlngs.length > 0) {

                            const outerRing = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;

                            if (outerRing && outerRing.length >= 3) {

                                isInside = isPointInPolygon(latLng, outerRing);

                            }

                        }

                    }

                } catch (error) {

                    console.error('Error checking polygon intersection:', error);

                    return;

                }

               

                if (isInside) {

                    const dogId = getDogId(markerData.row);

                    if (dogId && state.selectedMarkers.size < CONFIG.MAX_SELECTION) {

                        state.selectedMarkers.add(dogId);

                    }

                }

            });

        }

        function updateSelectedMarkersDisplay() {

            if (!state.markers || state.markers.length === 0) return;

           

            state.markers.forEach(markerData => {

                if (!markerData || !markerData.marker || !markerData.row) return;

               

                try {

                    const dogId = getDogId(markerData.row);

                    const isInSelection = dogId && state.selectedMarkers.has(dogId);

                    const isSelected = state.selectedMarker === markerData.marker;

                   

                    const driver = markerData.row['Driver'] || markerData.row['Combined'] || '';

                    let color = state.colorMap[driver] || '#999999';

                   

                    if (driver.toLowerCase().includes('unassigned')) {

                        color = '#000000';

                    }

                   

                    const newIcon = createMarkerIcon(color, isSelected, 'group', markerData.group, isInSelection, markerData.row['Dog Name'], markerData.row['Callout'] && markerData.row['Callout'].trim());

                    markerData.marker.setIcon(newIcon);

                } catch (error) {

                    console.error('Error updating marker display:', error);

                }

            });

           

            if (state.selectionMode) {

                showNotification(`Selected ${state.selectedMarkers.size} markers`, 'info', 1000);

            }

        }

        function updateBulkEditPanel() {

            const panel = document.getElementById('bulkEditPanel');

            if (!panel) return;

           

            if (state.selectedMarkers.size === 0) {

                panel.style.display = 'none';

                return;

            }

           

            panel.style.display = 'block';

           

            try {

                const selectedRows = [];

                for (const dogId of state.selectedMarkers) {

                    const markerData = state.markerLookup.get(dogId);

                    if (markerData && markerData.row) {

                        selectedRows.push(markerData.row);

                    }

                }

               

                const previewHtml = selectedRows.slice(0, 10).map(row => {

                    const dogName = escapeHtml(row['Dog Name'] || 'Unknown');

                    const driver = escapeHtml(row['Driver'] || row['Combined'] || 'No Driver');

                    return `<div class="selected-dog-item">${dogName} - ${driver}</div>`;

                }).join('');

               

                const moreText = selectedRows.length > 10 ?

                    `<div class="selected-dog-item">... and ${selectedRows.length - 10} more</div>` : '';

               

                panel.innerHTML = `

                    <div class="bulk-edit-panel">

                        <div class="bulk-edit-header">

                            <h4>üéØ Bulk Edit Selection</h4>

                            <span class="selected-count">${state.selectedMarkers.size} selected</span>

                        </div>

                        <div class="selected-dogs-preview">

                            ${previewHtml}

                            ${moreText}

                        </div>

                        <div class="bulk-edit-controls">

                            <input type="text" id="bulkDriverInput" class="bulk-edit-input"

                                   placeholder="New driver name"

                                   autocomplete="off" />

                            <button class="btn btn-primary" onclick="bulkUpdateSelected()"

                                    id="bulkUpdateBtn">üíæ Update All</button>

                            <button class="btn btn-secondary" onclick="clearSelection()">‚úñÔ∏è Cancel</button>

                        </div>

                    </div>

                `;

               

                setTimeout(() => {

                    const input = document.getElementById('bulkDriverInput');

                    if (input) input.focus();

                }, 100);

               

            } catch (error) {

                console.error('Error updating bulk edit panel:', error);

                panel.innerHTML = '<div class="error-message">Error loading selection panel</div>';

            }

        }

        function clearSelection() {

            state.selectedMarkers.clear();

            updateSelectedMarkersDisplay();

            updateBulkEditPanel();

           

            if (state.drawnItems) {

                state.drawnItems.clearLayers();

            }

           

            if (state.selectionMode) {

                showNotification('Selection cleared', 'info', 1000);

            }

        }

        // ==================== MARKER SELECTION ====================

        function selectMarker(marker, row, index, group) {

            if (!marker || !row || !state.map) {

                console.error('Invalid parameters for selectMarker');

                return;

            }

           

            try {

                // Clear previous selection

                if (state.selectedMarker && state.selectedMarker !== marker) {

                    const prevData = state.markers.find(m => m && m.marker === state.selectedMarker);

                    if (prevData) {

                        try {

                            const driver = prevData.row['Driver'] || prevData.row['Combined'] || '';

                            let color = state.colorMap[driver] || '#999999';

                           

                            if (driver.toLowerCase().includes('unassigned')) {

                                color = '#000000';

                            }

                           

                            const dogId = getDogId(prevData.row);

                            const isInSelection = dogId && state.selectedMarkers.has(dogId);

                            state.selectedMarker.setIcon(createMarkerIcon(color, false, 'group', prevData.group, isInSelection, prevData.row['Dog Name'], prevData.row['Callout'] && prevData.row['Callout'].trim()));

                        } catch (clearError) {

                            console.warn('Error clearing previous marker:', clearError);

                        }

                    }

                }

                state.selectedMarker = marker;

                state.selectedRow = row;

               

                // Update marker appearance

                try {

                    const driver = row['Driver'] || row['Combined'] || '';

                    let color = state.colorMap[driver] || '#999999';

                   

                    if (driver.toLowerCase().includes('unassigned')) {

                        color = '#000000';

                    }

                   

                    const dogId = getDogId(row);

                    const isInSelection = dogId && state.selectedMarkers.has(dogId);

                    marker.setIcon(createMarkerIcon(color, true, 'group', group, isInSelection, row['Dog Name'], row['Callout'] && row['Callout'].trim()));

                } catch (iconError) {

                    console.warn('Error updating marker icon:', iconError);

                }

                // Update details panel

                updateDetailsPanel(row, index);

               

            } catch (error) {

                console.error('Error in selectMarker:', error);

                showNotification('Error selecting marker', 'error');

            }

        }

        function updateDetailsPanel(row, index) {

            const detailsContent = document.getElementById('detailsContent');

            if (!detailsContent) return;

           

            try {

                // Use the stored _rowIndex or calculate it

                const actualIndex = row['_rowIndex'] ?? state.allData.indexOf(row);

                const driverName = row['Driver'] || '';

                const dogName = row['Dog Name'] || 'Unknown';

                const group = parseGroup(row['Group']);  // Parsed for shape display

                const groupText = row['Group'] || '';  // Original value with business codes

                const address = row['Address'] || '';

                const capacity = row['Capacity'] || '';

                const callout = row['Callout'] || '';

                const dogId = row['Dog ID'] || '';

               

                let infoHtml = '';

               

                // Build the info section

                infoHtml += `<div style="font-weight: bold; color: #333; margin-bottom: 8px; font-size: 14px; text-align: center; padding: 6px 8px; background: #f8f9fa; border-radius: 4px;">

                    ${escapeHtml(dogName)}

                </div>`;

               

                // Add group number - IMPORTANT: Keep this visual indicator with business codes visible

                infoHtml += `<div style="text-align: center; margin-bottom: 6px; font-size: 16px; font-weight: bold; color: #333;">

                    Group ${escapeHtml(groupText || '?')}

                </div>`;

               

                // Add Dog ID if present

                if (dogId) {

                    infoHtml += `<div style="margin-bottom: 6px; font-size: 11px; color: #999; text-align: center;">

                        ID: ${escapeHtml(dogId)}

                    </div>`;

                }

               

                // Add address if present

                if (address) {

                    infoHtml += `<div style="margin-bottom: 6px; font-size: 12px; color: #666;">

                        ${escapeHtml(address)}

                    </div>`;

                }

               

                // Add capacity if present

                if (capacity) {

                    infoHtml += `<div style="margin-bottom: 6px; font-size: 12px; color: #666;">

                        <strong>Capacity:</strong> ${escapeHtml(capacity)}

                    </div>`;

                }

               

                // Add callout if present

                if (callout) {

                    infoHtml += `<div style="background: #fff3cd; padding: 6px; border-radius: 4px; margin-bottom: 6px;">

                        <strong style="color: #856404;">CALLOUT:</strong>

                        <span style="color: #856404;">${escapeHtml(callout)}</span>

                    </div>`;

                }

               

                // Add driver and group edit section - using actualIndex properly

                const detailsHtml = `

                    ${infoHtml}

                   

                    <div style="border-top: 1px solid #dee2e6; padding-top: 8px; margin-top: 8px;">

                        <label style="font-size: 12px; color: #666; font-weight: 600; display: block; margin-bottom: 4px;">Driver:</label>

                        <div style="margin-bottom: 8px;">

                            <input type="text" id="editDriver" value="${escapeHtml(driverName)}"

                                   placeholder="Enter driver name"

                                   style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"

                                   autocomplete="off">

                        </div>

                       

                        <label style="font-size: 12px; color: #666; font-weight: 600; display: block; margin-bottom: 4px;">Group:</label>

                        <div style="margin-bottom: 8px;">

                            <input type="text" id="editGroup" value="${escapeHtml(groupText)}"

                                   placeholder="1, 2, 3, 1&2, 1DD1, 2SS2, etc."

                                   title="Supports business codes: DD, SS, AA, F (e.g., 1DD1, 2F2, 1SS&2)"

                                   style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;"

                                   autocomplete="off">

                        </div>

                       

                        <div style="display: flex; gap: 4px;">

                            <button class="btn btn-primary" onclick="saveMarkerData()"

                                    id="saveBtn" style="flex: 1; padding: 6px 8px; font-size: 12px;">

                                üíæ Save

                            </button>

                            <button class="btn btn-secondary" onclick="cancelEdit()"

                                    style="flex: 1; padding: 6px 8px; font-size: 12px;">

                                ‚úñÔ∏è Cancel

                            </button>

                        </div>

                    </div>

                `;

               

                detailsContent.innerHTML = detailsHtml;

               

                setTimeout(() => {

                    const driverInput = document.getElementById('editDriver');

                    const groupInput = document.getElementById('editGroup');

                   

                    if (driverInput) {

                        driverInput.focus();

                        driverInput.select();

                       

                        driverInput.addEventListener('keydown', function(e) {

                            if (e.key === 'Enter') {

                                e.preventDefault();

                                saveMarkerData();

                            } else if (e.key === 'Escape') {

                                e.preventDefault();

                                cancelEdit();

                            }

                        });

                    }

                   

                    if (groupInput) {

                        groupInput.addEventListener('keydown', function(e) {

                            if (e.key === 'Enter') {

                                e.preventDefault();

                                saveMarkerData();

                            } else if (e.key === 'Escape') {

                                e.preventDefault();

                                cancelEdit();

                            }

                        });

                    }

                }, 100);

               

            } catch (error) {

                console.error('Error updating details panel:', error);

                detailsContent.innerHTML = '<div class="error-message">Error showing details</div>';

            }

        }

        // ==================== LEGEND ====================

        function updateLegend() {

            const legendContent = document.getElementById('legendContent');

            if (!legendContent) return;

           

            try {

                const sortedEntries = Object.entries(state.colorMap).sort(([a], [b]) => a.localeCompare(b));

                const legendItems = [];

               

                sortedEntries.forEach(([key, color]) => {

                    if (!key || !color) return;

                   

                    const isActive = state.currentFilter === key;

                    let displayText = escapeHtml(key);

                   

                    // Add group counts for drivers

                    if (state.allData && state.allData.length > 0) {

                        // Count dogs by group for this driver

                        const groupCounts = { 1: 0, 2: 0, 3: 0 };

                       

                        state.allData.forEach(row => {

                            if (!row) return;

                            const rowDriver = row['Driver'] || row['Combined'] || '';

                            if (rowDriver !== key) return;

                           

                            // Get the number of dogs (default to 1 if not specified)

                            const dogCount = parseInt(row['Number of Dogs'] || '1') || 1;

                            // Add this debug line:

                            console.log(`Dog: ${row['Dog Name']}, Group: ${row['Group']}, Raw: "${row['Number of Dogs']}", Count: ${dogCount}`);

                            // Parse the group assignment (handles business codes)

                            const group = parseGroup(row['Group']);

                           

                            if (group !== null) {

                                if (typeof group === 'string' && group.length > 1) {

                                    // Multi-group: split and add to each

                                    group.split('').forEach(g => {

                                        const groupNum = parseInt(g);

                                        if (groupNum >= 1 && groupNum <= 3) {

                                            groupCounts[groupNum] += dogCount;

                                        }

                                    });

                                } else if (typeof group === 'number' && group >= 1 && group <= 3) {

                                    // Single group

                                    groupCounts[group] += dogCount;

                                }

                            }

                        });

                       

                        // Only show counts if there are any dogs

                        const total = groupCounts[1] + groupCounts[2] + groupCounts[3];

                        if (total > 0) {

                            displayText += ` (${groupCounts[1]}, ${groupCounts[2]}, ${groupCounts[3]})`;

                        }

                    }

                   

                    const dataKey = escapeHtml(key);

                    const safeKey = key.replace(/'/g, "\\'").replace(/"/g, '\\"').replace(/\\/g, '\\\\');

                   

                    legendItems.push(`

                        <div class="legend-item ${isActive ? 'active' : ''}"

                             onclick="filterByCategory('${safeKey}')"

                             role="button"

                             tabindex="0"

                             aria-label="Filter by ${dataKey}"

                             aria-pressed="${isActive}">

                            <div class="legend-color" style="background-color: ${color}"></div>

                            <span class="legend-text">${displayText}</span>

                            <input type="color" class="color-picker" value="${color}"

                                   data-category="${dataKey}"

                                   aria-label="Change color for ${dataKey}"

                                   onclick="event.stopPropagation()" />

                        </div>

                    `);

                });

               

                legendContent.innerHTML = legendItems.join('') || '<div class="no-selection">No drivers found</div>';

               

                // Add color picker handlers

                const pickers = legendContent.querySelectorAll('.color-picker');

                pickers.forEach(picker => {

                    picker.addEventListener('change', function(e) {

                        e.stopPropagation();

                        const categoryName = this.getAttribute('data-category');

                        if (categoryName) {

                            changeCustomColor(categoryName, this.value);

                        }

                    });

                    picker.addEventListener('click', e => e.stopPropagation());

                });

               

            } catch (error) {

                console.error('Error updating legend:', error);

                legendContent.innerHTML = '<div class="error-message">Error loading legend</div>';

            }

        }

        // ==================== EVENT HANDLERS ====================

        function toggleGroupFilter(group) {

            const btn = document.getElementById(`group${group}Btn`);

            if (!btn) return;

           

            const index = state.activeGroups.indexOf(group);

           

            if (index > -1) {

                if (state.activeGroups.length > 1) {

                    state.activeGroups.splice(index, 1);

                    btn.classList.remove('active');

                    btn.setAttribute('aria-pressed', 'false');

                } else {

                    showNotification('At least one group must remain active', 'error');

                    return;

                }

            } else {

                state.activeGroups.push(group);

                state.activeGroups.sort();

                btn.classList.add('active');

                btn.setAttribute('aria-pressed', 'true');

            }

           

            updateMap();

        }

        function filterByCategory(category) {

            state.currentFilter = state.currentFilter === category ? null : category;

            updateMap();

           

            if (state.currentFilter) {

                showNotification(`Filtering by: ${category}`, 'info', 2000);

            } else {

                showNotification('Filter cleared', 'info', 2000);

            }

        }

        function clearFilter() {

            state.currentFilter = null;

            const searchInput = document.getElementById('searchInput');

            if (searchInput) searchInput.value = '';

            updateMap();

            showNotification('All filters cleared', 'info', 2000);

        }

        function resetColors() {

            if (Object.keys(state.customColors).length === 0) {

                showNotification('No custom colors to reset', 'info');

                return;

            }

           

            console.log('Resetting all custom colors');

            state.customColors = {};

            assignDriverColors();

            updateMap();

            showNotification('All custom colors reset', 'success');

        }

        function togglePanel() {

            const panel = document.getElementById('leftPanel');

            const toggle = document.getElementById('panelToggle');

            const icon = document.getElementById('panelToggleIcon');

           

            if (panel && toggle && icon) {

                panel.classList.toggle('open');

                icon.textContent = panel.classList.contains('open') ? '‚ñ∂' : '‚óÄ';

            }

        }

        // ==================== SAVE FUNCTIONS WITH GOOGLE SHEETS INTEGRATION ====================

        async function saveMarkerData() {

            const editDriverInput = document.getElementById('editDriver');

            const editGroupInput = document.getElementById('editGroup');

            const saveBtn = document.getElementById('saveBtn');

           

            if (!editDriverInput || !editGroupInput) {

                showNotification('Error: Edit fields not found', 'error');

                return;

            }

           

            const newDriverName = editDriverInput.value.trim();

            const newGroupValue = editGroupInput.value.trim();

           

            if (!state.selectedRow) {

                showNotification('Error: No row selected', 'error');

                return;

            }

            try {

                // Disable save button

                if (saveBtn) {

                    saveBtn.disabled = true;

                    saveBtn.innerHTML = '‚è≥ Saving...';

                }

               

                const oldDriver = state.selectedRow['Driver'] || '';

                const oldGroup = state.selectedRow['Group'] || '';

               

                // Get the correct sheet row index

                const sheetRowIndex = getSheetRowIndex(state.selectedRow);

               

                if (sheetRowIndex === -1) {

                    throw new Error('Could not determine row index');

                }

               

                console.log('Saving to sheet row:', sheetRowIndex, 'for dog:', state.selectedRow['Dog Name']);

               

                // Update local data immediately for responsive UI

                state.selectedRow['Driver'] = newDriverName;

                state.selectedRow['Group'] = newGroupValue;

               

                // Update the marker's group property and icon

                const dogId = getDogId(state.selectedRow);

                const markerData = state.markerLookup.get(dogId);

                if (markerData) {

                    // Update the group in markerData

                    markerData.group = parseGroup(newGroupValue);

                   

                    // Update the marker icon with new shape based on group

                    const driver = newDriverName || state.selectedRow['Combined'] || '';

                    let color = state.colorMap[driver] || '#999999';

                   

                    if (driver.toLowerCase().includes('unassigned')) {

                        color = '#000000';

                    }

                   

                    const isInSelection = dogId && state.selectedMarkers.has(dogId);

                    const hasCallout = state.selectedRow['Callout'] && state.selectedRow['Callout'].trim();

                   

                    // Update marker icon with new group shape

                    const newIcon = createMarkerIcon(color, true, 'group', markerData.group, isInSelection, state.selectedRow['Dog Name'], hasCallout);

                    markerData.marker.setIcon(newIcon);

                }

               

                // Update UI immediately

                assignDriverColors();

                updateMap();

               

                // Show immediate feedback

                showNotification('Saving to Google Sheets...', 'info', 1000);

               

                // Send to Google Sheets with both fields

                const payload = {

                    action: 'updateRow',

                    rowIndex: sheetRowIndex,  // Already includes +2 adjustment

                    updatedData: {

                        'Driver': newDriverName,

                        'Group': newGroupValue

                    }

                };

               

                await callAppsScript(payload);

               

                showNotification('‚úÖ Data updated in Google Sheets!', 'success', 2000);

               

                // Re-enable button

                if (saveBtn) {

                    saveBtn.disabled = false;

                    saveBtn.innerHTML = 'üíæ Save';

                }

               

            } catch (error) {

                console.error('Error in saveMarkerData:', error);

                showNotification(`Error saving: ${error.message}`, 'error');

               

                // Restore button state

                if (saveBtn) {

                    saveBtn.disabled = false;

                    saveBtn.innerHTML = 'üíæ Save';

                }

               

                // Revert local changes on error

                if (state.selectedRow && typeof oldDriver !== 'undefined') {

                    state.selectedRow['Driver'] = oldDriver;

                    state.selectedRow['Group'] = oldGroup;

                    assignDriverColors();

                    updateMap();

                }

            }

        }

        // Keep the old function name for backward compatibility, redirect to new one

        async function saveDriverName() {

            return saveMarkerData();

        }

        async function bulkUpdateSelected() {

            if (!state.selectionMode) {

                showNotification('Not in selection mode', 'error');

                return;

            }

           

            const bulkInput = document.getElementById('bulkDriverInput');

            const bulkBtn = document.getElementById('bulkUpdateBtn');

           

            if (!bulkInput) {

                showNotification('Interface not ready. Please try again.', 'error');

                return;

            }

           

            const newDriverName = bulkInput.value.trim();

            if (!newDriverName) {

                showNotification('Please enter a driver name', 'error');

                bulkInput.focus();

                return;

            }

           

            if (state.selectedMarkers.size === 0) {

                showNotification('No markers selected', 'error');

                return;

            }

           

            try {

                const validSelectedRows = [];

                const sheetRowIndices = [];

               

                for (const dogId of state.selectedMarkers) {

                    const markerData = state.markerLookup.get(dogId);

                    if (markerData && markerData.row) {

                        const sheetRowIndex = getSheetRowIndex(markerData.row);

                        if (sheetRowIndex !== -1) {

                            validSelectedRows.push(markerData.row);

                            sheetRowIndices.push(sheetRowIndex);

                        }

                    }

                }

               

                if (validSelectedRows.length === 0) {

                    showNotification('No valid markers selected', 'error');

                    return;

                }

               

                if (!confirm(`Update ${validSelectedRows.length} dogs with driver name: "${newDriverName}"?`)) {

                    return;

                }

               

                // Disable button

                if (bulkBtn) {

                    bulkBtn.disabled = true;

                    bulkBtn.innerHTML = '‚è≥ Updating...';

                }

               

                // Store old values for rollback

                const oldValues = validSelectedRows.map(row => ({

                    row: row,

                    oldDriver: row['Driver'] || ''

                }));

               

                // Update local data immediately for responsive UI

                validSelectedRows.forEach(row => {

                    row['Driver'] = newDriverName;

                });

               

                // Update UI immediately

                assignDriverColors();

                updateMap();

                clearSelection();

               

                showNotification(`Saving ${validSelectedRows.length} updates to Google Sheets...`, 'info');

               

                // Prepare bulk update payload

                const updates = sheetRowIndices.map(sheetRowIndex => ({

                    rowIndex: sheetRowIndex,  // Already includes +2 adjustment

                    updatedData: {

                        'Driver': newDriverName

                    }

                }));

               

                console.log('Bulk updating rows:', sheetRowIndices);

               

                const payload = {

                    action: 'bulkUpdate',

                    updates: updates

                };

               

                await callAppsScript(payload);

               

                showNotification(`‚úÖ Successfully updated ${validSelectedRows.length} dogs in Google Sheets!`, 'success', 3000);

               

                // Re-enable button

                if (bulkBtn) {

                    bulkBtn.disabled = false;

                    bulkBtn.innerHTML = 'üíæ Update All';

                }

               

            } catch (error) {

                console.error('Bulk update error:', error);

                showNotification(`Error during bulk update: ${error.message}`, 'error');

               

                // Re-enable button

                if (bulkBtn) {

                    bulkBtn.disabled = false;

                    bulkBtn.innerHTML = 'üíæ Update All';

                }

               

                // Rollback local changes on error

                if (oldValues) {

                    oldValues.forEach(({row, oldDriver}) => {

                        row['Driver'] = oldDriver;

                    });

                    assignDriverColors();

                    updateMap();

                }

            }

        }

        function cancelEdit() {

            if (state.selectedMarker && state.selectedRow) {

                const markerData = state.markers.find(m => m && m.marker === state.selectedMarker);

                if (markerData) {

                    const index = state.selectedRow['_rowIndex'] ?? state.allData.indexOf(state.selectedRow);

                    selectMarker(state.selectedMarker, state.selectedRow, index, markerData.group);

                }

            }

        }

        // ==================== INITIALIZATION ====================

        const debouncedUpdateMap = debounce(updateMap, CONFIG.DEBOUNCE_DELAY);

        function initializeApp() {

            try {

                console.log('DOM loaded, initializing application...');

               

                // Check browser compatibility

                const requiredFeatures = [

                    'Promise' in window,

                    'fetch' in window,

                    'Map' in window,

                    'Set' in window,

                    'requestAnimationFrame' in window

                ];

               

                const missingFeatures = requiredFeatures.filter((feature, index) => {

                    const featureName = ['Promise', 'fetch', 'Map', 'Set', 'requestAnimationFrame'][index];

                    if (!eval(feature)) {

                        console.error(`Missing required feature: ${featureName}`);

                        return true;

                    }

                    return false;

                });

               

                if (missingFeatures.length > 0) {

                    showNotification('Your browser is missing required features. Please use a modern browser.', 'error', 0);

                    return;

                }

               

                // Initialize map

                initMap();

               

                // Load initial data

                loadData();

               

                // Test Apps Script connection after a short delay

                setTimeout(() => testAppsScriptConnection(), 2000);

               

                // Setup event listeners

                const searchInput = document.getElementById('searchInput');

                if (searchInput) {

                    searchInput.addEventListener('input', debouncedUpdateMap);

                    searchInput.addEventListener('search', debouncedUpdateMap);

                }

               

                // Group filter buttons

                document.getElementById('group1Btn')?.addEventListener('click', () => toggleGroupFilter(1));

                document.getElementById('group2Btn')?.addEventListener('click', () => toggleGroupFilter(2));

                document.getElementById('group3Btn')?.addEventListener('click', () => toggleGroupFilter(3));

               

                // Other buttons

                document.getElementById('selectionModeBtn')?.addEventListener('click', toggleSelectionMode);

                document.getElementById('clearSelectionBtn')?.addEventListener('click', clearSelection);

                document.getElementById('resetColorsBtn')?.addEventListener('click', resetColors);

                document.getElementById('showAllBtn')?.addEventListener('click', clearFilter);

                document.getElementById('panelToggle')?.addEventListener('click', togglePanel);

                document.getElementById('testConnectionBtn')?.addEventListener('click', testAppsScriptConnection);

               

                // Add keyboard shortcuts

                document.addEventListener('keydown', function(e) {

                    // Escape key

                    if (e.key === 'Escape') {

                        if (state.selectionMode) {

                            toggleSelectionMode();

                        } else if (state.selectedMarker) {

                            state.selectedMarker = null;

                            state.selectedRow = null;

                            updateMap();

                            const detailsContent = document.getElementById('detailsContent');

                            if (detailsContent) {

                                detailsContent.innerHTML = '<div class="no-selection">Click a marker to edit</div>';

                            }

                        }

                    }

                   

                    // Ctrl/Cmd + F for search focus

                    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {

                        e.preventDefault();

                        const searchInput = document.getElementById('searchInput');

                        if (searchInput) {

                            searchInput.focus();

                            searchInput.select();

                        }

                    }

                });

               

                console.log('Application initialized successfully');

                console.log('Google Sheets Write-back Enabled - Driver and Group Editing');

                console.log('Business codes supported: DD (Discount Day), SS (Single Siblings), AA, F');

                console.log('Example patterns: 1DD1‚Üí‚≠ï, 2F2‚Üí‚ñ≤, 3SS3‚Üí‚ñ†, 1DD&2‚Üí‚≠ê, 2AA&3‚Üí‚ØÉ, 1SS23‚Üí‚¨¢');

               

            } catch (error) {

                console.error('Error during application initialization:', error);

                showNotification('Failed to initialize application', 'error', 0);

            }

        }

        // Global functions for onclick handlers

        window.filterByCategory = filterByCategory;

        window.clearSelection = clearSelection;

        window.saveDriverName = saveDriverName;

        window.saveMarkerData = saveMarkerData;

        window.cancelEdit = cancelEdit;

        window.bulkUpdateSelected = bulkUpdateSelected;

        window.testAppsScriptConnection = testAppsScriptConnection;

        // Global error handler

        window.addEventListener('error', function(event) {

            console.error('Global error:', event.error);

            console.error('Stack:', event.error?.stack);

           

            // If error is related to group parsing, provide helpful info

            if (event.error?.message?.includes('group') || event.error?.message?.includes('Group')) {

                console.log('Group parsing tip: Supported business codes are DD, SS, AA, F');

                console.log('Valid patterns: 1, 2, 3, 1DD1, 2F2, 1&2, 1DD&2, 123, 1SS23, etc.');

            }

        });

        // Initialize when DOM is ready

        document.addEventListener('DOMContentLoaded', initializeApp);

        console.log('Dog Walking Map v2.4 - Business Codes Support (DD, SS, AA, F)');

    </script>

</body>

</html>

